{"version":3,"sources":["figures/circle.js","figures/triangle.js","components/FigureSelect.js","components/Inputs.js","components/Result.js","App.js","index.js"],"names":["Circle","this","nameForSelect","numOfParams","description","params","radius","result","square","Math","PI","err","Triangle","a","b","c","p","sqrt","sides","slice","sort","note","heronFormula","Select","props","figures","options","figureKey","push","value","name","onInput","handleChangeFigure","Input","inputs","i","figure","className","type","id","values","onChange","selectedFigure","checkValues","Result","App","circle","triangle","state","bind","handleInput","map","Number","findIndex","num","isNaN","e","newFigure","target","newValues","Array","setState","calculate","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f8db78ee.chunk.js","sourcesContent":["export default class Circle {\n  constructor() {\n    this.nameForSelect = 'круг';\n    this.numOfParams = 1;\n    this.description = 'Введите радиус';\n  }\n\n  calculate(params) {\n    const radius = params[0];\n    return {\n      result: {\n        square: Math.PI * radius * radius,\n      },\n      err: false\n    };\n  }\n}","export default class Triangle {\n  constructor() {\n    this.nameForSelect = 'треугольник';\n    this.numOfParams = 3;\n    this.description = 'Введите три стороны треугольника';\n  }\n\n  /*\n    Спорный вопрос с короткими именами переменных.\n    Но в случае с локальным использованием: только внутри класса\n    и учитывая предметную область: стороны треугольника,\n    то наверное можно\n  */\n\n  heronFormula(a, b, c) {\n    const p = (a + b + c) / 2;\n    return Math.sqrt(p * (p - a) * (p - b) * (p - c));\n  }\n\n  calculate(params) {\n    const sides = params.slice();\n    sides.sort((a, b) => a - b);\n\n    const a = sides[0];\n    const b = sides[1];\n    const c = sides[2];\n\n    const result = {};\n    \n    if (a + b <= c) {\n      result.result = false;\n      result.err = 'Треугольник не существует';\n      return result;\n    }\n\n    result.result = {};\n    result.err = false;\n\n    if (a * a + b * b === c * c) {\n      result.result.square = a * b / 2;\n      result.result.note = 'Треугольник прямоугольный';\n      return result;\n    }\n    \n    result.result.square = this.heronFormula(a, b, c);\n \n    return result;\n  }\n}","export default function Select(props) {\n  const figures = props.figures;\n  const options = [];\n  for (let figureKey in figures) {\n    options.push(\n      <option value={figureKey} key={figureKey}>{figures[figureKey].nameForSelect}</option>\n    );\n  }    \n  \n  return (\n    <select\n      name=\"select\"\n      value={props.value}\n      onInput={props.handleChangeFigure}>\n        {options}\n    </select>\n  );\n}","export default function Input(props) {\n  const inputs = [];\n  for (let i = 0; i < props.figure.numOfParams; i += 1) {\n    inputs.push(\n      <input\n        className=\"inputs-input\"\n        type=\"text\"\n        key={props.selectedFigure + i}\n        id={i}\n        value={props.values[i]}\n        onChange={props.onChange}\n      />\n    )\n  }\n\n  return (\n    <div className=\"inputs\">\n      <div className=\"inputs-description\">{props.figure.description}</div>\n      <div className=\"inputs-inputs-list\">\n        {inputs}\n      </div>\n      {!props.checkValues() && \n        <div className=\"iputs-validate-message\">Введите числа больше нуля во все поля</div>\n      }\n    </div>\n  );\n}","export default function Result(props) {  \n  if (props.result.err) {\n    return (\n      <div className=\"result\">\n        <div className=\"result-error\">{props.result.err}</div>\n      </div>\n    );\n  }\n\n  const result = props.result.result;\n  \n  return (\n    <div className=\"result\">\n      <div className=\"result-square\">Площадь: {result.square}</div>\n      {result.note &&\n        <div>Заметка: {result.note}</div>\n      }\n    </div>\n  );\n}","import React from 'react';\n\n// figures\nimport Circle from './figures/circle';\nimport Triangle from './figures/triangle';\n\n// components\nimport Select from './components/FigureSelect';\nimport Inputs from './components/Inputs';\nimport Result from './components/Result';\n\nexport default class App extends React.Component {\n  constructor() {\n    super();\n    this.figures = {\n      circle: new Circle(),\n      triangle: new Triangle(),\n    }\n    this.state = {\n      selectedFigure: 'circle',\n      values: [''],\n    }\n    this.handleChangeFigure = this.handleChangeFigure.bind(this);\n    this.handleInput = this.handleInput.bind(this);\n    this.checkValues = this.checkValues.bind(this);\n  }\n\n  checkValues() {\n    const numbers = this.state.values.map((i) => Number(i));\n    const badIndex = numbers.findIndex((num) => (isNaN(num) || num <= 0));\n    return badIndex === -1;\n  }\n\n  /*\n    Тут можно подумать о том как сохранять ранее введенные пользователем значения\n    Пример кейса выбрал круг -> ввел число -> выбрал треугольник -> появились два новых поля ->\n    выбрал круг обратно -> введенное в первое поле число сохранилось\n  */\n  handleChangeFigure(e) {\n    const newFigure = e.target.value;\n    const newValues = new Array(this.figures[newFigure].numOfParams);\n    this.setState({\n      selectedFigure: newFigure,\n      values: newValues,\n    });\n  }\n\n  /* \n    Почему-то при вводе значений после смены фигуры возникает ошибка неконтролируемого ввода\n    Но все работает\n  */\n  handleInput(e) {\n    this.setState((state) => {\n      const id = e.target.id;\n      const value = e.target.value;\n      const newValues = state.values.slice();\n      newValues[id] = value;\n      return {values: newValues};\n    });\n  }\n\n  render() {   \n    return (\n      <div className=\"column\">\n        <Select\n          figures={this.figures}\n          value={this.state.selectedFigure}\n          handleChangeFigure={this.handleChangeFigure}\n        />\n        <Inputs \n          figure={this.figures[this.state.selectedFigure]}\n          selectedFigure={this.state.selectedFigure}\n          values={this.state.values}\n          onChange={this.handleInput}\n          checkValues={this.checkValues}\n        />\n        {this.checkValues() &&\n          <Result\n            result={this.figures[this.state.selectedFigure].calculate(this.state.values.map((i) => Number(i)))}\n          />\n        }\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './style.css'\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}